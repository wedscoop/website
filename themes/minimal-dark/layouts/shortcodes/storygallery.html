{{ $images := $.Page.Resources.Match "gallery/*.{jpg,jpeg,png,webp}" }}
{{ $storyblocks := .Page.Params.storyblocks }}

{{ if not (len $images) }}
  <p class="text-gray-400 text-center py-8">No images found in the gallery.</p>
{{ else }}
  <div class="story-gallery max-w-6xl mx-auto">

    {{ $open := false }}

    {{ range $i, $img := $images }}
      {{ $name := path.Base $img.Name | lower }}
      {{ $block := dict }}

      <!-- ‚úÖ Prefix Matching -->
      {{ range $key, $value := $storyblocks }}
        {{ $prefix := $key | lower }}
        {{ if strings.HasPrefix $name $prefix }}
          {{ $block = $value }}
        {{ end }}
      {{ end }}

      {{ if $block }}
        {{ if $open }}</div>{{ $open = false }}{{ end }}

        <!-- Full-width Story Block -->
        <section class="story-block fade-in-block">
          {{ if eq $block.type "text" }}
            <p class="text-gray-300 text-base md:text-lg leading-relaxed text-center mb-4"
               style="font-family: 'Lato', sans-serif;">
              {{ $block.content }}
            </p>

          {{ else if eq $block.type "youtube" }}
            <div class="aspect-video w-full rounded-lg overflow-hidden shadow-lg mb-2">
              <iframe
                src="https://www.youtube.com/embed/{{ $block.videoId }}?rel=0"
                frameborder="0"
                allowfullscreen
                class="w-full h-full">
              </iframe>
              {{ if $block.caption }}
                <p class="text-gray-400 text-sm text-center mt-2">{{ $block.caption }}</p>
              {{ end }}
            </div>

          {{ else if eq $block.type "quote" }}
            <div class="relative w-full rounded-lg overflow-hidden shadow-md mb-2 fade-in-block group">
              <a href="{{ $img.RelPermalink }}" 
                 class="glightbox block" 
                 data-gallery="gallery-{{ $.Page.File.Path | urlize }}">
                <img
                  data-src="{{ $img.RelPermalink }}"
                  alt="{{ $img.Name }}"
                  loading="lazy"
                  decoding="async"
                  class="lazy-image w-full h-auto object-cover opacity-0"
                >
                <div class="absolute bottom-0 left-0 w-full bg-gradient-to-t from-black/80 to-transparent py-4 px-6">
                  <p class="italic text-[#d1d1d1] text-base md:text-xl font-light text-center leading-snug"
                     style="font-family: 'Raleway', sans-serif;">
                    ‚Äú{{ $block.content }}‚Äù
                  </p>
                </div>
              </a>
            </div>
          {{ end }}
        </section>

      {{ else }}
        {{ if not $open }}
          <div class="gallery-grid mb-4">
          {{ $open = true }}
        {{ end }}

        <!-- Masonry Image Tile -->
        <a href="{{ $img.RelPermalink }}" 
           class="glightbox block relative overflow-hidden rounded-lg shadow-md fade-in-tile"
           data-gallery="gallery-{{ $.Page.File.Path | urlize }}">
          <img
            data-src="{{ $img.RelPermalink }}"
            alt="{{ $img.Name }}"
            loading="lazy"
            decoding="async"
            class="lazy-image w-full h-auto object-cover opacity-0"
          >
        </a>
      {{ end }}
    {{ end }}

    {{ if $open }}</div>{{ end }}
  </div>
{{ end }}

<style>
/* Masonry layout */
.gallery-grid {
  display: grid;
  align-items: start;
  gap: 0.5rem;
  column-gap: 0.3rem;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  grid-auto-rows: 10px;
  width: 100%;
}
.gallery-grid > a {
  display: block;
  break-inside: avoid;
  position: relative;
  overflow: hidden;       /* ensures clean clipping */
  line-height: 0;         /* removes inline gap below images */
}

/* Story container styling */
.story-gallery {
  width: 100%;
}
.story-block {
  width: 100%;
  margin: 1rem 0;
  padding: 0;
}
.story-block iframe,
.story-block img {
  border-radius: 0.5rem;
  width: 100%;
}

/* Animations */
@keyframes fadeInUp {
  0% { opacity: 0; transform: translateY(12px); }
  100% { opacity: 1; transform: translateY(0); }
}
.fade-in-tile,
.fade-in-block {
  opacity: 0;
  animation: fadeInUp 0.8s ease-out forwards;
}
.fade-in-tile:nth-child(2n) { animation-delay: 0.1s; }
.fade-in-tile:nth-child(3n) { animation-delay: 0.2s; }
.fade-in-block { animation-delay: 0.1s; }

/* ‚úÖ Smooth hover effects for all images */
.gallery-grid a img,
.story-block a img {
  transition: transform 0.9s cubic-bezier(0.25, 0.1, 0.25, 1),
              filter 0.9s cubic-bezier(0.25, 0.1, 0.25, 1);
  will-change: transform, filter;
}
.gallery-grid a:hover img,
.story-block a:hover img {
  transform: scale(1.04);
  filter: brightness(1.05);
}

/* Lazy image transition */
img.lazy-image {
  transition: opacity 0.3s ease-out;
}
img.lazy-image.loaded {
  opacity: 1;
}

/* ‚úÖ Fix bottom gap without affecting layout */
.gallery-grid a img {
  width: 100%;
  height: auto;
  display: block;
  object-fit: cover;
  vertical-align: bottom;
}

/* ‚úÖ Flush alignment (no visual gap between rows) */
.gallery-grid a {
  margin-bottom: -0.25rem; /* subtle overlap to fix sub-pixel gaps */
}

.gallery-grid a img {
  display: block;
  width: 100%;
  height: auto;
  object-fit: cover;
  line-height: 0;
  margin: 0;
  padding: 0;
  vertical-align: bottom; /* ensures no extra inline gap */
}
</style>

<script>
/* Lazy loading + Masonry height recalculation */
document.addEventListener("DOMContentLoaded", () => {
  const lazyImages = document.querySelectorAll("img.lazy-image");

  // Masonry adjustment function
  function adjustMasonry(grid) {
    if (!grid) return;
    const rowHeight = parseInt(window.getComputedStyle(grid).getPropertyValue('grid-auto-rows'));
    const gap = parseInt(window.getComputedStyle(grid).getPropertyValue('gap'));
    grid.querySelectorAll('a').forEach(item => {
      const img = item.querySelector('img');
      if (!img || !img.complete) return;
	  const span = Math.ceil((img.getBoundingClientRect().height + gap * 0.5) / (rowHeight + gap));
      item.style.gridRowEnd = `span ${span}`;
    });
  }

  // Lazy load observer
  if ("IntersectionObserver" in window) {
    const observer = new IntersectionObserver((entries, obs) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          img.src = img.dataset.src;

          img.onload = () => {
            img.classList.add("loaded");
            const grid = img.closest(".gallery-grid");
            if (grid) adjustMasonry(grid); // üîß recalc row height after load
          };

          obs.unobserve(img);
        }
      });
    }, { rootMargin: "300px 0px" });
    lazyImages.forEach(img => observer.observe(img));
  } else {
    // Fallback for older browsers
    lazyImages.forEach(img => {
      img.src = img.dataset.src;
      img.onload = () => {
        img.classList.add("loaded");
        const grid = img.closest(".gallery-grid");
        if (grid) adjustMasonry(grid);
      };
    });
  }

  // Initial recalculation after load (in case some are visible)
  window.addEventListener("load", () => {
    document.querySelectorAll(".gallery-grid").forEach(grid => adjustMasonry(grid));
  });
});

/* --- Batch loader --- */
document.addEventListener("DOMContentLoaded", () => {
  const allTiles = Array.from(document.querySelectorAll(".gallery-grid a"));
  const batchSize = 12;
  let currentIndex = batchSize;
  let loading = false;
  let suspended = false; // when true we won't auto-trigger until user scrolls

  // hide everything beyond the first batch
  allTiles.forEach((el, i) => {
    if (i >= batchSize) el.style.display = "none";
  });

  // sentinel (marker) at the bottom
  const sentinel = document.createElement("div");
  sentinel.id = "batch-sentinel";
  sentinel.style.height = "1px";
  // make it a bit below the last content so it doesn't start 'visible' immediately
  sentinel.style.marginTop = "300px";
  document.querySelector(".story-gallery").appendChild(sentinel);

  /* helper: load an <img> and resolve when loaded (or error) */
  function loadImage(img) {
    return new Promise(resolve => {
      if (!img) return resolve();
      if (img.complete && img.naturalWidth) return resolve();
      img.addEventListener("load", () => resolve(), { once: true });
      img.addEventListener("error", () => resolve(), { once: true });
      // if image uses data-src pattern, kick it off
      if (img.dataset && img.dataset.src && !img.src) img.src = img.dataset.src;
    });
  }

  /* helper: wait for all images in an array to load or until timeout (ms) */
  function waitForImagesLoaded(imgs, timeout = 1500) {
    return new Promise(resolve => {
      if (!imgs.length) return resolve();
      let done = 0;
      let finished = false;
      imgs.forEach(img => {
        loadImage(img).then(() => {
          done++;
          // attempt to call user's masonry adjust function if present:
          try {
            const grid = img.closest(".gallery-grid");
            if (grid && typeof adjustMasonry === "function") adjustMasonry(grid);
          } catch (e) { /* ignore */ }

          if (done >= imgs.length && !finished) {
            finished = true;
            resolve();
          }
        });
      });
      // safety timeout
      setTimeout(() => {
        if (!finished) {
          finished = true;
          resolve();
        }
      }, timeout);
    });
  }

  async function loadNextBatch() {
    // guard
    if (loading) return;
    if (currentIndex >= allTiles.length) return cleanup();

    loading = true;
    suspended = false;

    // temporarily stop observing to avoid double triggers
    try { observer.unobserve(sentinel); } catch (e) {}

    const next = allTiles.slice(currentIndex, currentIndex + batchSize);
    if (!next.length) {
      loading = false;
      return cleanup();
    }

    console.log(`Loading batch: ${currentIndex} ‚Üí ${currentIndex + next.length - 1}`);

    // Reveal tiles and kick off image loads immediately (so layout expands sooner)
    const imgElems = [];
    next.forEach(el => {
      el.style.display = "block";
      el.classList.add("fade-in-tile");
      const img = el.querySelector("img.lazy-image") || el.querySelector("img");
      if (img) {
        // ensure dataset src is triggered (in case lazy observer isn't attached yet)
        if (img.dataset && img.dataset.src && !img.src) img.src = img.dataset.src;
        imgElems.push(img);
      }
    });

    currentIndex += next.length;

    // Wait for images to load (or timeout) so the DOM height actually increases
    await waitForImagesLoaded(imgElems, 1400);

    // If we've shown all, clean up
    if (currentIndex >= allTiles.length) {
      loading = false;
      return cleanup();
    }

    // Check whether sentinel is now below the viewport
    const rect = sentinel.getBoundingClientRect();
    const sentinelBelowViewport = rect.top > window.innerHeight + 5;

    if (sentinelBelowViewport) {
      // safe to observe again (normal flow)
      loading = false;
      try { observer.observe(sentinel); } catch (e) {}
      return;
    }

    // sentinel still visible ‚Äî suspend automatic triggers and wait for user scroll
    suspended = true;
    loading = false;

    // one-time scroll handler: user explicitly scrolls -> request next batch once
    function onUserScrollOnce() {
      window.removeEventListener("scroll", onUserScrollOnce);
      // small delay to let scroll settle
      setTimeout(() => {
        // clear suspended and load next batch (user intent)
        suspended = false;
        loadNextBatch();
      }, 120);
    }
    window.addEventListener("scroll", onUserScrollOnce, { passive: true });
  }

  // IntersectionObserver ‚Äî kept conservative to avoid pre-triggering
  const observer = new IntersectionObserver(entries => {
    const entry = entries[0];
    if (!entry) return;
    // only trigger when sentinel intersects, we are not loading, and not suspended
    if (entry.isIntersecting && !loading && !suspended) {
      // small guard to avoid firing too early on page load
      if (window.scrollY < 60 && document.documentElement.scrollHeight <= window.innerHeight + 100) {
        // very short page ‚Äî do not auto-fire; user will scroll or we will show more via other means
        return;
      }
      loadNextBatch();
    }
  }, { rootMargin: "0px", threshold: 0.01 });

  observer.observe(sentinel);

  // Scroll fallback (safety net) ‚Äî respects loading & suspended flags
  function scrollFallback() {
    if (loading || suspended) return;
    const threshold = document.body.offsetHeight - 160;
    if (window.innerHeight + window.scrollY >= threshold) loadNextBatch();
  }
  window.addEventListener("scroll", scrollFallback, { passive: true });

  function cleanup() {
    try { observer.disconnect(); } catch (e) {}
    window.removeEventListener("scroll", scrollFallback);
    if (sentinel && sentinel.parentNode) sentinel.parentNode.removeChild(sentinel);
    console.log("All batches loaded or no more tiles.");
  }

  // Safety: if content is extremely short and reveals everything on first paint,
  // we can attempt to show more automatically but controlled (optional).
  // This is intentionally conservative to avoid mass-loading many batches at once.
});
</script>
