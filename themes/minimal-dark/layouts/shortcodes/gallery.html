<div class="gallery-masonry-grid">
  {{ $images := $.Page.Resources.Match "gallery/*.{jpg,jpeg,png,webp}" }}
  {{ if not (len $images) }}
    <p class="text-gray-400">No images found in the gallery.</p>
  {{ else }}
    {{ range $images }}
      {{ if in .MediaType.Type "image" }}
        {{ $img := . }}
        <a href="{{ $img.RelPermalink }}" 
           class="glightbox masonry-item" 
           data-gallery="gallery-{{ $.Page.File.Path | urlize }}">
          <picture>
            <source type="image/webp" srcset="{{ $img.RelPermalink }}" />
            <img src="{{ $img.RelPermalink }}" 
                 alt="{{ $img.Name }}" 
                 loading="lazy" 
                 decoding="async" 
                 class="w-full h-auto object-cover rounded-lg" />
          </picture>
        </a>
      {{ end }}
    {{ end }}
  {{ end }}
</div>

<style>
/* ✅ Grid-based masonry layout (row-wise order) */
.gallery-masonry-grid {
  display: grid;
  grid-template-columns: repeat(1, 1fr);
  grid-auto-rows: 8px; /* base row height */
  gap: 4px; /* small uniform gaps */
}

@media (min-width: 640px) {
  .gallery-masonry-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}
@media (min-width: 768px) {
  .gallery-masonry-grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

.masonry-item {
  display: block;
  width: 100%;
  overflow: hidden;
  border-radius: 0.5rem; /* rounded corners */
  break-inside: avoid;
}

.masonry-item img {
  display: block;
  width: 100%;
  height: auto;
  object-fit: cover;
  transition: transform 300ms ease, opacity 200ms ease;
}

.masonry-item:hover img {
  transform: scale(1.03);
  opacity: 0.95;
}
</style>

<script>
/* ✅ JS for correct row-wise masonry height calculation */
(function () {
  function resizeMasonryItem(item, grid) {
    const img = item.querySelector('img');
    if (!img) return;
    const rowHeight = parseInt(window.getComputedStyle(grid).getPropertyValue('grid-auto-rows'));
    const rowGap = parseInt(window.getComputedStyle(grid).getPropertyValue('gap'));
    const itemHeight = img.getBoundingClientRect().height;
    const rowSpan = Math.ceil((itemHeight + rowGap) / (rowHeight + rowGap));
    item.style.gridRowEnd = 'span ' + rowSpan;
  }

  function relayoutMasonry(grid) {
    const items = grid.querySelectorAll('.masonry-item');
    items.forEach(item => resizeMasonryItem(item, grid));
  }

  document.addEventListener('DOMContentLoaded', function () {
    const grid = document.querySelector('.gallery-masonry-grid');
    if (!grid) return;

    const imgs = grid.querySelectorAll('img');
    imgs.forEach(img => {
      if (img.complete) {
        relayoutMasonry(grid);
      } else {
        img.addEventListener('load', () => relayoutMasonry(grid));
        img.addEventListener('error', () => relayoutMasonry(grid));
      }
    });

    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => relayoutMasonry(grid), 150);
    });

    relayoutMasonry(grid);
  });
})();
</script>
